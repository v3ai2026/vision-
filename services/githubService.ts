
/**
 * GitHub API Service: Enterprise-grade SCM Orchestration.
 * Handles repository lifecycle, file synchronization, and project provisioning.
 */
export class GitHubService {
  private baseUrl = 'https://api.github.com';

  constructor(private token: string) {
    if (!token) throw new Error("GitHub SCM Protocol requires a valid access token.");
  }

  private getHeaders() {
    return {
      'Authorization': `token ${this.token}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    };
  }

  private encodeContent(content: string): string {
    const bytes = new TextEncoder().encode(content);
    const binString = Array.from(bytes, (byte) => String.fromCharCode(byte)).join("");
    return btoa(binString);
  }

  /**
   * Fetches the authenticated user's profile.
   */
  async getAuthenticatedUser() {
    const response = await fetch(`${this.baseUrl}/user`, {
      headers: this.getHeaders(),
    });
    if (!response.ok) {
      throw new Error(`User Fetch Error: ${response.statusText}`);
    }
    return response.json();
  }

  /**
   * Fetches the SHA of a file if it exists.
   */
  async getFileSha(owner: string, repo: string, path: string): Promise<string | undefined> {
    try {
      const response = await fetch(`${this.baseUrl}/repos/${owner}/${repo}/contents/${path}`, {
        headers: this.getHeaders(),
      });
      if (response.ok) {
        const data = await response.json();
        return data.sha;
      }
      return undefined;
    } catch {
      return undefined;
    }
  }

  /**
   * Provisions a new repository.
   */
  async provisionProject(name: string, description: string, isPrivate: boolean = true, autoInitReadme: boolean = true) {
    console.log(`[GitHub Service] Provisioning repository: ${name}`);
    
    const repoResponse = await fetch(`${this.baseUrl}/user/repos`, {
      method: 'POST',
      headers: this.getHeaders(),
      body: JSON.stringify({
        name,
        description,
        private: isPrivate,
        auto_init: false,
      }),
    });

    if (!repoResponse.ok) {
      const error = await repoResponse.json();
      throw new Error(`Provisioning Error: ${error.message || repoResponse.statusText}`);
    }

    const repoData = await repoResponse.json();
    const owner = repoData.owner.login;

    if (autoInitReadme) {
      // Initialize with README.md immediately
      await this.pushFile(
        owner,
        name,
        'README.md',
        `# ${name}\n\n${description}\n\nGenerated by IntelliBuild Studio Core.`,
        '[Initial Protocol] Initialize project structure'
      );
    }

    return repoData;
  }

  /**
   * Pushes or updates a file in a specific repository path.
   * Now automatically fetches SHA to allow updating existing files.
   */
  async pushFile(owner: string, repo: string, path: string, content: string, message: string) {
    const sha = await this.getFileSha(owner, repo, path);
    const contentBase64 = this.encodeContent(content);
    const body: any = { message, content: contentBase64 };
    if (sha) body.sha = sha;

    const response = await fetch(`${this.baseUrl}/repos/${owner}/${repo}/contents/${path}`, {
      method: 'PUT',
      headers: this.getHeaders(),
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Sync Error (${path}): ${error.message || response.statusText}`);
    }

    return response.json();
  }

  /**
   * Bulk synchronizes a project shard (array of files).
   */
  async pushProjectFiles(owner: string, repo: string, files: { path: string; content: string }[]) {
    const results = [];
    for (const file of files) {
      const res = await this.pushFile(
        owner,
        repo,
        file.path,
        file.content,
        `[Orchestration] Sync file: ${file.path.split('/').pop()}`
      );
      results.push(res);
    }
    return results;
  }
}
